import {
  useColor
} from "./chunk-BDDQD3Y7.js";
import {
  getCurrentInstance,
  getCurrentInstanceName,
  propsFactory
} from "./chunk-LM4E4B67.js";
import {
  Fragment,
  computed,
  createVNode,
  onBeforeUnmount,
  onMounted,
  resolveDynamicComponent,
  toRef,
  unref
} from "./chunk-DNXM2JDJ.js";
import {
  __spreadProps,
  __spreadValues,
  init_define_process_env
} from "./chunk-PWHOG2Q4.js";

// node_modules/vuetify/lib/composables/variant.mjs
init_define_process_env();
var allowedVariants = ["outlined", "plain", "text", "contained", "contained-flat", "contained-text"];
function genOverlays(isClickable, name) {
  return createVNode(Fragment, null, [isClickable && createVNode("div", {
    "class": `${name}__overlay`
  }, null), createVNode("div", {
    "class": `${name}__underlay`
  }, null)]);
}
var makeVariantProps = propsFactory({
  color: String,
  variant: {
    type: String,
    default: "contained",
    validator: (v) => allowedVariants.includes(v)
  }
}, "variant");
function useVariant(props) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const variantClasses = computed(() => {
    const {
      variant
    } = unref(props);
    return `${name}--variant-${variant}`;
  });
  const {
    colorClasses,
    colorStyles
  } = useColor(computed(() => {
    const {
      variant,
      color
    } = unref(props);
    return {
      [["contained", "contained-flat"].includes(variant) ? "background" : "text"]: color
    };
  }));
  return {
    colorClasses,
    colorStyles,
    variantClasses
  };
}

// node_modules/vuetify/lib/composables/router.mjs
init_define_process_env();
function useRouter() {
  var _getCurrentInstance, _getCurrentInstance$p;
  return (_getCurrentInstance = getCurrentInstance("useRouter")) == null ? void 0 : (_getCurrentInstance$p = _getCurrentInstance.proxy) == null ? void 0 : _getCurrentInstance$p.$router;
}
function useLink(props, attrs) {
  const RouterLink = resolveDynamicComponent("RouterLink");
  const isLink = computed(() => !!(props.href || props.to));
  const isClickable = computed(() => {
    return (isLink == null ? void 0 : isLink.value) || !!(attrs.onClick || attrs.onClickOnce);
  });
  if (typeof RouterLink === "string") {
    return {
      isLink,
      isClickable,
      href: toRef(props, "href")
    };
  }
  const link = props.to ? RouterLink.useLink(props) : void 0;
  return __spreadProps(__spreadValues({}, link), {
    isLink,
    isClickable,
    href: computed(() => props.to ? link == null ? void 0 : link.route.value.href : props.href)
  });
}
var makeRouterProps = propsFactory({
  href: String,
  replace: Boolean,
  to: [String, Object]
}, "router");
var inTransition = false;
function useBackButton(cb) {
  const router = useRouter();
  let popped = false;
  let removeBefore;
  let removeAfter;
  onMounted(() => {
    window.addEventListener("popstate", onPopstate);
    removeBefore = router == null ? void 0 : router.beforeEach((to, from, next) => {
      if (!inTransition) {
        setTimeout(() => popped ? cb(next) : next());
      } else {
        popped ? cb(next) : next();
      }
      inTransition = true;
    });
    removeAfter = router == null ? void 0 : router.afterEach(() => {
      inTransition = false;
    });
  });
  onBeforeUnmount(() => {
    var _removeBefore, _removeAfter;
    window.removeEventListener("popstate", onPopstate);
    (_removeBefore = removeBefore) == null ? void 0 : _removeBefore();
    (_removeAfter = removeAfter) == null ? void 0 : _removeAfter();
  });
  function onPopstate(e) {
    var _e$state;
    if ((_e$state = e.state) != null && _e$state.replaced)
      return;
    popped = true;
    setTimeout(() => popped = false);
  }
}

export {
  genOverlays,
  makeVariantProps,
  useVariant,
  useLink,
  makeRouterProps,
  useBackButton
};
//# sourceMappingURL=chunk-FRYW3QMR.js.map
