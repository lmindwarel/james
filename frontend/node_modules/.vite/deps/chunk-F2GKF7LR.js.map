{
  "version": 3,
  "sources": ["../../vuetify/src/directives/ripple/index.ts"],
  "sourcesContent": ["// Styles\nimport './VRipple.sass'\n\n// Utilities\nimport { isObject, keyCodes } from '@/util'\n\n// Types\nimport type {\n  DirectiveBinding,\n  ObjectDirective,\n} from 'vue'\n\nconst stopSymbol = Symbol('rippleStop')\n\ntype VuetifyRippleEvent = (MouseEvent | TouchEvent | KeyboardEvent) & { [stopSymbol]?: boolean }\n\nconst DELAY_RIPPLE = 80\n\nfunction transform (el: HTMLElement, value: string) {\n  el.style.transform = value\n  el.style.webkitTransform = value\n}\n\nfunction opacity (el: HTMLElement, value: number) {\n  el.style.opacity = `calc(${value} * var(--v-theme-overlay-multiplier))`\n}\n\ninterface RippleOptions {\n  class?: string\n  center?: boolean\n  circle?: boolean\n}\n\nexport interface RippleDirectiveBinding extends Omit<DirectiveBinding, 'modifiers' | 'value'> {\n  value?: boolean | { class: string }\n  modifiers: {\n    center?: boolean\n    circle?: boolean\n    stop?: boolean\n  }\n}\n\nfunction isTouchEvent (e: VuetifyRippleEvent): e is TouchEvent {\n  return e.constructor.name === 'TouchEvent'\n}\n\nfunction isKeyboardEvent (e: VuetifyRippleEvent): e is KeyboardEvent {\n  return e.constructor.name === 'KeyboardEvent'\n}\n\nconst calculate = (\n  e: VuetifyRippleEvent,\n  el: HTMLElement,\n  value: RippleOptions = {}\n) => {\n  let localX = 0\n  let localY = 0\n\n  if (!isKeyboardEvent(e)) {\n    const offset = el.getBoundingClientRect()\n    const target = isTouchEvent(e) ? e.touches[e.touches.length - 1] : e\n\n    localX = target.clientX - offset.left\n    localY = target.clientY - offset.top\n  }\n\n  let radius = 0\n  let scale = 0.3\n  if (el._ripple?.circle) {\n    scale = 0.15\n    radius = el.clientWidth / 2\n    radius = value.center ? radius : radius + Math.sqrt((localX - radius) ** 2 + (localY - radius) ** 2) / 4\n  } else {\n    radius = Math.sqrt(el.clientWidth ** 2 + el.clientHeight ** 2) / 2\n  }\n\n  const centerX = `${(el.clientWidth - (radius * 2)) / 2}px`\n  const centerY = `${(el.clientHeight - (radius * 2)) / 2}px`\n\n  const x = value.center ? centerX : `${localX - radius}px`\n  const y = value.center ? centerY : `${localY - radius}px`\n\n  return { radius, scale, x, y, centerX, centerY }\n}\n\nconst ripples = {\n  /* eslint-disable max-statements */\n  show (\n    e: VuetifyRippleEvent,\n    el: HTMLElement,\n    value: RippleOptions = {}\n  ) {\n    if (!el?._ripple?.enabled) {\n      return\n    }\n\n    const container = document.createElement('span')\n    const animation = document.createElement('span')\n\n    container.appendChild(animation)\n    container.className = 'v-ripple__container'\n\n    if (value.class) {\n      container.className += ` ${value.class}`\n    }\n\n    const { radius, scale, x, y, centerX, centerY } = calculate(e, el, value)\n\n    const size = `${radius * 2}px`\n    animation.className = 'v-ripple__animation'\n    animation.style.width = size\n    animation.style.height = size\n\n    el.appendChild(container)\n\n    const computed = window.getComputedStyle(el)\n    if (computed && computed.position === 'static') {\n      el.style.position = 'relative'\n      el.dataset.previousPosition = 'static'\n    }\n\n    animation.classList.add('v-ripple__animation--enter')\n    animation.classList.add('v-ripple__animation--visible')\n    transform(animation, `translate(${x}, ${y}) scale3d(${scale},${scale},${scale})`)\n    opacity(animation, 0)\n    animation.dataset.activated = String(performance.now())\n\n    setTimeout(() => {\n      animation.classList.remove('v-ripple__animation--enter')\n      animation.classList.add('v-ripple__animation--in')\n      transform(animation, `translate(${centerX}, ${centerY}) scale3d(1,1,1)`)\n      opacity(animation, 0.08)\n    }, 0)\n  },\n\n  hide (el: HTMLElement | null) {\n    if (!el?._ripple?.enabled) return\n\n    const ripples = el.getElementsByClassName('v-ripple__animation')\n\n    if (ripples.length === 0) return\n    const animation = ripples[ripples.length - 1]\n\n    if (animation.dataset.isHiding) return\n    else animation.dataset.isHiding = 'true'\n\n    const diff = performance.now() - Number(animation.dataset.activated)\n    const delay = Math.max(250 - diff, 0)\n\n    setTimeout(() => {\n      animation.classList.remove('v-ripple__animation--in')\n      animation.classList.add('v-ripple__animation--out')\n      opacity(animation, 0)\n\n      setTimeout(() => {\n        const ripples = el.getElementsByClassName('v-ripple__animation')\n        if (ripples.length === 1 && el.dataset.previousPosition) {\n          el.style.position = el.dataset.previousPosition\n          delete el.dataset.previousPosition\n        }\n\n        animation.parentNode && el.removeChild(animation.parentNode)\n      }, 300)\n    }, delay)\n  },\n}\n\nfunction isRippleEnabled (value: any): value is true {\n  return typeof value === 'undefined' || !!value\n}\n\nfunction rippleShow (e: VuetifyRippleEvent) {\n  const value: RippleOptions = {}\n  const element = e.currentTarget as HTMLElement | undefined\n\n  if (!element?._ripple || element._ripple.touched || e[stopSymbol]) return\n\n  // Don't allow the event to trigger ripples on any other elements\n  e[stopSymbol] = true\n\n  if (isTouchEvent(e)) {\n    element._ripple.touched = true\n    element._ripple.isTouch = true\n  } else {\n    // It's possible for touch events to fire\n    // as mouse events on Android/iOS, this\n    // will skip the event call if it has\n    // already been registered as touch\n    if (element._ripple.isTouch) return\n  }\n\n  value.center = element._ripple.centered || isKeyboardEvent(e)\n  if (element._ripple.class) {\n    value.class = element._ripple.class\n  }\n\n  if (isTouchEvent(e)) {\n    // already queued that shows or hides the ripple\n    if (element._ripple.showTimerCommit) return\n\n    element._ripple.showTimerCommit = () => {\n      ripples.show(e, element, value)\n    }\n    element._ripple.showTimer = window.setTimeout(() => {\n      if (element?._ripple?.showTimerCommit) {\n        element._ripple.showTimerCommit()\n        element._ripple.showTimerCommit = null\n      }\n    }, DELAY_RIPPLE)\n  } else {\n    ripples.show(e, element, value)\n  }\n}\n\nfunction rippleStop (e: VuetifyRippleEvent) {\n  e[stopSymbol] = true\n}\n\nfunction rippleHide (e: Event) {\n  const element = e.currentTarget as HTMLElement | null\n  if (!element || !element._ripple) return\n\n  window.clearTimeout(element._ripple.showTimer)\n\n  // The touch interaction occurs before the show timer is triggered.\n  // We still want to show ripple effect.\n  if (e.type === 'touchend' && element._ripple.showTimerCommit) {\n    element._ripple.showTimerCommit()\n    element._ripple.showTimerCommit = null\n\n    // re-queue ripple hiding\n    element._ripple.showTimer = window.setTimeout(() => {\n      rippleHide(e)\n    })\n    return\n  }\n\n  window.setTimeout(() => {\n    if (element._ripple) {\n      element._ripple.touched = false\n    }\n  })\n  ripples.hide(element)\n}\n\nfunction rippleCancelShow (e: MouseEvent | TouchEvent) {\n  const element = e.currentTarget as HTMLElement | undefined\n\n  if (!element || !element._ripple) return\n\n  if (element._ripple.showTimerCommit) {\n    element._ripple.showTimerCommit = null\n  }\n\n  window.clearTimeout(element._ripple.showTimer)\n}\n\nlet keyboardRipple = false\n\nfunction keyboardRippleShow (e: KeyboardEvent) {\n  if (!keyboardRipple && (e.keyCode === keyCodes.enter || e.keyCode === keyCodes.space)) {\n    keyboardRipple = true\n    rippleShow(e)\n  }\n}\n\nfunction keyboardRippleHide (e: KeyboardEvent) {\n  keyboardRipple = false\n  rippleHide(e)\n}\n\nfunction focusRippleHide (e: FocusEvent) {\n  if (keyboardRipple) {\n    keyboardRipple = false\n    rippleHide(e)\n  }\n}\n\nfunction updateRipple (el: HTMLElement, binding: RippleDirectiveBinding, wasEnabled: boolean) {\n  const { value, modifiers } = binding\n  const enabled = isRippleEnabled(value)\n  if (!enabled) {\n    ripples.hide(el)\n  }\n\n  el._ripple = el._ripple ?? {}\n  el._ripple.enabled = enabled\n  el._ripple.centered = modifiers.center\n  el._ripple.circle = modifiers.circle\n  if (isObject(value) && value.class) {\n    el._ripple.class = value.class\n  }\n\n  if (enabled && !wasEnabled) {\n    if (modifiers.stop) {\n      el.addEventListener('touchstart', rippleStop, { passive: true })\n      el.addEventListener('mousedown', rippleStop)\n      return\n    }\n\n    el.addEventListener('touchstart', rippleShow, { passive: true })\n    el.addEventListener('touchend', rippleHide, { passive: true })\n    el.addEventListener('touchmove', rippleCancelShow, { passive: true })\n    el.addEventListener('touchcancel', rippleHide)\n\n    el.addEventListener('mousedown', rippleShow)\n    el.addEventListener('mouseup', rippleHide)\n    el.addEventListener('mouseleave', rippleHide)\n\n    el.addEventListener('keydown', keyboardRippleShow)\n    el.addEventListener('keyup', keyboardRippleHide)\n\n    el.addEventListener('blur', focusRippleHide)\n\n    // Anchor tags can be dragged, causes other hides to fail - #1537\n    el.addEventListener('dragstart', rippleHide, { passive: true })\n  } else if (!enabled && wasEnabled) {\n    removeListeners(el)\n  }\n}\n\nfunction removeListeners (el: HTMLElement) {\n  el.removeEventListener('mousedown', rippleShow)\n  el.removeEventListener('touchstart', rippleShow)\n  el.removeEventListener('touchend', rippleHide)\n  el.removeEventListener('touchmove', rippleCancelShow)\n  el.removeEventListener('touchcancel', rippleHide)\n  el.removeEventListener('mouseup', rippleHide)\n  el.removeEventListener('mouseleave', rippleHide)\n  el.removeEventListener('keydown', keyboardRippleShow)\n  el.removeEventListener('keyup', keyboardRippleHide)\n  el.removeEventListener('dragstart', rippleHide)\n  el.removeEventListener('blur', focusRippleHide)\n}\n\nfunction mounted (el: HTMLElement, binding: DirectiveBinding) {\n  updateRipple(el, binding, false)\n}\n\nfunction unmounted (el: HTMLElement) {\n  delete el._ripple\n  removeListeners(el)\n}\n\nfunction updated (el: HTMLElement, binding: DirectiveBinding) {\n  if (binding.value === binding.oldValue) {\n    return\n  }\n\n  const wasEnabled = isRippleEnabled(binding.oldValue)\n  updateRipple(el, binding, wasEnabled)\n}\n\nexport const Ripple: ObjectDirective = {\n  mounted,\n  unmounted,\n  updated,\n}\n\nexport default Ripple\n"],
  "mappings": "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",
  "names": []
}
