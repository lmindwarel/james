import {
  Ripple
} from "./chunk-F2GKF7LR.js";
import {
  makeDensityProps,
  useDensity
} from "./chunk-6WTCDHCV.js";
import {
  makeBorderProps,
  makeElevationProps,
  useBorder,
  useElevation
} from "./chunk-SDQGVKLX.js";
import {
  VIcon,
  makeSizeProps,
  useSize
} from "./chunk-M7F3MEY4.js";
import {
  makeTagProps
} from "./chunk-HUVCJMGT.js";
import {
  makePositionProps,
  usePosition
} from "./chunk-GWCMY4D6.js";
import {
  genOverlays,
  makeRouterProps,
  makeVariantProps,
  useLink,
  useVariant
} from "./chunk-FRYW3QMR.js";
import {
  makeDimensionProps,
  useDimension
} from "./chunk-F2IVWHVX.js";
import {
  useProxiedModel
} from "./chunk-IZ7W3NCM.js";
import {
  makeRoundedProps,
  useRounded
} from "./chunk-UCBRT5BW.js";
import {
  makeThemeProps,
  provideTheme
} from "./chunk-HJLBJ25A.js";
import {
  consoleWarn,
  deepEqual,
  defineComponent,
  findChildrenWithProvide,
  genericComponent,
  getCurrentInstance,
  getUid,
  propsFactory,
  provideDefaults,
  useRender,
  wrapInArray
} from "./chunk-LM4E4B67.js";
import {
  computed,
  createVNode,
  inject,
  nextTick,
  onBeforeUnmount,
  onMounted,
  provide,
  reactive,
  resolveDirective,
  toRef,
  watch,
  withDirectives
} from "./chunk-DNXM2JDJ.js";
import {
  __spreadValues,
  init_define_process_env
} from "./chunk-PWHOG2Q4.js";

// node_modules/vuetify/lib/components/VBtn/VBtn.mjs
init_define_process_env();
import "/home/antoine/dev/go/src/github.com/james/frontend/node_modules/vuetify/lib/components/VBtn/VBtn.css";

// node_modules/vuetify/lib/components/VBtnToggle/VBtnToggle.mjs
init_define_process_env();
import "/home/antoine/dev/go/src/github.com/james/frontend/node_modules/vuetify/lib/components/VBtnToggle/VBtnToggle.css";

// node_modules/vuetify/lib/components/VBtnGroup/index.mjs
init_define_process_env();

// node_modules/vuetify/lib/components/VBtnGroup/VBtnGroup.mjs
init_define_process_env();
import "/home/antoine/dev/go/src/github.com/james/frontend/node_modules/vuetify/lib/components/VBtnGroup/VBtnGroup.css";
var VBtnGroup = defineComponent({
  name: "VBtnGroup",
  props: __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    divided: Boolean
  }, makeBorderProps()), makeDensityProps()), makeElevationProps()), makeRoundedProps()), makeTagProps()), makeThemeProps()), makeVariantProps()),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      densityClasses
    } = useDensity(props);
    const {
      borderClasses
    } = useBorder(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      roundedClasses
    } = useRounded(props);
    provideDefaults({
      VBtn: {
        height: "auto",
        color: toRef(props, "color"),
        density: toRef(props, "density"),
        flat: true,
        variant: toRef(props, "variant")
      }
    });
    useRender(() => {
      return createVNode(props.tag, {
        "class": ["v-btn-group", {
          "v-btn-group--divided": props.divided
        }, themeClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, roundedClasses.value]
      }, slots);
    });
  }
});

// node_modules/vuetify/lib/composables/group.mjs
init_define_process_env();
var makeGroupProps = propsFactory({
  modelValue: {
    type: null,
    default: void 0
  },
  multiple: Boolean,
  mandatory: [Boolean, String],
  max: Number,
  selectedClass: String,
  disabled: Boolean
}, "group");
var makeGroupItemProps = propsFactory({
  value: null,
  disabled: Boolean,
  selectedClass: String
}, "group-item");
function useGroupItem(props, injectKey) {
  let required = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  const vm = getCurrentInstance("useGroupItem");
  if (!vm) {
    throw new Error("[Vuetify] useGroupItem composable must be used inside a component setup function");
  }
  const id = getUid();
  provide(Symbol.for(`${injectKey.description}:id`), id);
  const group = inject(injectKey, null);
  if (!group) {
    if (!required)
      return group;
    throw new Error(`[Vuetify] Could not find useGroup injection with symbol ${injectKey.description}`);
  }
  const value = toRef(props, "value");
  const disabled = computed(() => group.disabled.value || props.disabled);
  group.register({
    id,
    value,
    disabled
  }, vm);
  onBeforeUnmount(() => {
    group.unregister(id);
  });
  const isSelected = computed(() => {
    return group.isSelected(id);
  });
  const selectedClass = computed(() => isSelected.value && [group.selectedClass.value, props.selectedClass]);
  watch(isSelected, (value2) => {
    vm.emit("group:selected", {
      value: value2
    });
  });
  return {
    id,
    isSelected,
    toggle: () => group.select(id, !isSelected.value),
    select: (value2) => group.select(id, value2),
    selectedClass,
    value,
    disabled,
    group
  };
}
function useGroup(props, injectKey) {
  let isUnmounted = false;
  const items = reactive([]);
  const selected = useProxiedModel(props, "modelValue", [], (v) => {
    if (v == null)
      return [];
    return getIds(items, wrapInArray(v));
  }, (v) => {
    const arr = getValues(items, v);
    return props.multiple ? arr : arr[0];
  });
  const groupVm = getCurrentInstance("useGroup");
  function register(item, vm) {
    const unwrapped = item;
    const key = Symbol.for(`${injectKey.description}:id`);
    const children = findChildrenWithProvide(key, groupVm == null ? void 0 : groupVm.vnode);
    const index = children.indexOf(vm);
    if (index > -1) {
      items.splice(index, 0, unwrapped);
    } else {
      items.push(unwrapped);
    }
  }
  function unregister(id) {
    if (isUnmounted)
      return;
    forceMandatoryValue();
    const index = items.findIndex((item) => item.id === id);
    items.splice(index, 1);
  }
  function forceMandatoryValue() {
    const item = items.find((item2) => !item2.disabled);
    if (item && props.mandatory === "force" && !selected.value.length) {
      selected.value = [item.id];
    }
  }
  onMounted(() => {
    forceMandatoryValue();
  });
  onBeforeUnmount(() => {
    isUnmounted = true;
  });
  function select(id, value) {
    const item = items.find((item2) => item2.id === id);
    if (value && item != null && item.disabled)
      return;
    if (props.multiple) {
      var _value;
      const internalValue = selected.value.slice();
      const index = internalValue.findIndex((v) => v === id);
      const isSelected = ~index;
      value = (_value = value) != null ? _value : !isSelected;
      if (isSelected && props.mandatory && internalValue.length <= 1)
        return;
      if (!isSelected && props.max != null && internalValue.length + 1 > props.max)
        return;
      if (index < 0 && value)
        internalValue.push(id);
      else if (index >= 0 && !value)
        internalValue.splice(index, 1);
      selected.value = internalValue;
    } else {
      var _value2;
      const isSelected = selected.value.includes(id);
      if (props.mandatory && isSelected)
        return;
      selected.value = ((_value2 = value) != null ? _value2 : !isSelected) ? [id] : [];
    }
  }
  function step(offset) {
    if (props.multiple)
      consoleWarn('This method is not supported when using "multiple" prop');
    if (!selected.value.length) {
      const item = items.find((item2) => !item2.disabled);
      item && (selected.value = [item.id]);
    } else {
      const currentId = selected.value[0];
      const currentIndex = items.findIndex((i) => i.id === currentId);
      let newIndex = (currentIndex + offset) % items.length;
      let newItem = items[newIndex];
      while (newItem.disabled && newIndex !== currentIndex) {
        newIndex = (newIndex + offset) % items.length;
        newItem = items[newIndex];
      }
      if (newItem.disabled)
        return;
      selected.value = [items[newIndex].id];
    }
  }
  const state = {
    register,
    unregister,
    selected,
    select,
    disabled: toRef(props, "disabled"),
    prev: () => step(items.length - 1),
    next: () => step(1),
    isSelected: (id) => selected.value.includes(id),
    selectedClass: computed(() => props.selectedClass),
    items: computed(() => items),
    getItemIndex: (value) => getItemIndex(items, value)
  };
  provide(injectKey, state);
  return state;
}
function getItemIndex(items, value) {
  const ids = getIds(items, [value]);
  if (!ids.length)
    return -1;
  return items.findIndex((item) => item.id === ids[0]);
}
function getIds(items, modelValue) {
  const ids = [];
  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    if (item.value != null) {
      if (modelValue.find((value) => deepEqual(value, item.value)) != null) {
        ids.push(item.id);
      }
    } else if (modelValue.includes(i)) {
      ids.push(item.id);
    }
  }
  return ids;
}
function getValues(items, ids) {
  const values = [];
  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    if (ids.includes(item.id)) {
      values.push(item.value != null ? item.value : i);
    }
  }
  return values;
}

// node_modules/vuetify/lib/components/VBtnToggle/VBtnToggle.mjs
var VBtnToggleSymbol = Symbol.for("vuetify:v-btn-toggle");
var VBtnToggle = genericComponent()({
  name: "VBtnToggle",
  props: makeGroupProps({
    selectedClass: "v-btn--selected"
  }),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      isSelected,
      next,
      prev,
      select,
      selected
    } = useGroup(props, VBtnToggleSymbol);
    useRender(() => {
      var _slots$default;
      return createVNode(VBtnGroup, {
        "class": "v-btn-toggle"
      }, {
        default: () => [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, {
          isSelected,
          next,
          prev,
          select,
          selected
        })]
      });
    });
    return {
      next,
      prev,
      select
    };
  }
});

// node_modules/vuetify/lib/composables/selectLink.mjs
init_define_process_env();
function useSelectLink(link, select) {
  watch(() => {
    var _link$isExactActive;
    return (_link$isExactActive = link.isExactActive) == null ? void 0 : _link$isExactActive.value;
  }, (isExactActive) => {
    if (link.isLink.value && isExactActive && select) {
      nextTick(() => {
        select(true);
      });
    }
  }, {
    immediate: true
  });
}

// node_modules/vuetify/lib/components/VBtn/VBtn.mjs
var VBtn = defineComponent({
  name: "VBtn",
  directives: {
    Ripple
  },
  props: __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    active: Boolean,
    symbol: {
      type: null,
      default: VBtnToggleSymbol
    },
    flat: Boolean,
    icon: [Boolean, String],
    prependIcon: String,
    appendIcon: String,
    block: Boolean,
    stacked: Boolean,
    ripple: {
      type: Boolean,
      default: true
    }
  }, makeBorderProps()), makeRoundedProps()), makeDensityProps()), makeDimensionProps()), makeElevationProps()), makeGroupItemProps()), makePositionProps()), makeRouterProps()), makeSizeProps()), makeTagProps({
    tag: "button"
  })), makeThemeProps()), makeVariantProps({
    variant: "contained"
  })),
  setup(props, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      borderClasses
    } = useBorder(props);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(props);
    const {
      densityClasses
    } = useDensity(props);
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      positionClasses,
      positionStyles
    } = usePosition(props);
    const {
      roundedClasses
    } = useRounded(props);
    const {
      sizeClasses
    } = useSize(props);
    const group = useGroupItem(props, props.symbol, false);
    const link = useLink(props, attrs);
    const isDisabled = computed(() => (group == null ? void 0 : group.disabled.value) || props.disabled);
    const isElevated = computed(() => {
      return props.variant === "contained" && !(props.disabled || props.flat || props.border);
    });
    useSelectLink(link, group == null ? void 0 : group.select);
    return () => {
      var _slots$default;
      const Tag = link.isLink.value ? "a" : props.tag;
      const hasColor = !group || group.isSelected.value;
      return withDirectives(createVNode(Tag, {
        "type": Tag === "a" ? void 0 : "button",
        "class": ["v-btn", group == null ? void 0 : group.selectedClass.value, {
          "v-btn--active": props.active,
          "v-btn--block": props.block,
          "v-btn--disabled": isDisabled.value,
          "v-btn--elevated": isElevated.value,
          "v-btn--flat": props.flat,
          "v-btn--icon": !!props.icon,
          "v-btn--stacked": props.stacked
        }, themeClasses.value, borderClasses.value, hasColor ? colorClasses.value : void 0, densityClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value],
        "style": [hasColor ? colorStyles.value : void 0, dimensionStyles.value, positionStyles.value],
        "disabled": isDisabled.value || void 0,
        "href": link.href.value,
        "onClick": (e) => {
          var _link$navigate;
          if (isDisabled.value)
            return;
          (_link$navigate = link.navigate) == null ? void 0 : _link$navigate.call(link, e);
          group == null ? void 0 : group.toggle();
        }
      }, {
        default: () => [genOverlays(true, "v-btn"), !props.icon && props.prependIcon && createVNode(VIcon, {
          "class": "v-btn__icon",
          "icon": props.prependIcon,
          "start": true
        }, null), typeof props.icon === "boolean" ? (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots) : createVNode(VIcon, {
          "class": "v-btn__icon",
          "icon": props.icon,
          "size": props.size
        }, null), !props.icon && props.appendIcon && createVNode(VIcon, {
          "class": "v-btn__icon",
          "icon": props.appendIcon,
          "end": true
        }, null)]
      }), [[resolveDirective("ripple"), !isDisabled.value && props.ripple, null]]);
    };
  }
});

// node_modules/vuetify/lib/components/VBtn/index.mjs
init_define_process_env();

export {
  makeGroupItemProps,
  useGroupItem,
  useGroup,
  VBtn
};
//# sourceMappingURL=chunk-PZKKGCYZ.js.map
